#!/usr/bin/python
#
# Copyright 2014 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Refer to the README and COPYING files for full details of the license
#

"""
Parse repoStats log lines and plot graphs of lastCheck and read delay for all
storage domains.

Usage: repoplot vdsm.log [...]

Requirements: python-pandas
"""

import argparse
import fileinput
import sys

from collections import defaultdict
from collections import namedtuple

# Use non-interactive backend so we can generate graphs on a headless server.
# See http://matplotlib.org/faq/howto_faq.html#howto-webapp
import matplotlib
matplotlib.use("Agg")

import pandas
from matplotlib import pyplot


def main(args):
    args = parse_args(args)
    stats = parse(args.files)
    filename = "%s.%s" % ((args.name or args.files[0]), args.format)
    plot(stats, filename, (args.width, args.height))


def parse_args(args):
    parser = argparse.ArgumentParser(
        description="Visualize storage monitoring")
    parser.add_argument("--name", "-n", dest="name",
                        help="output file name (default first log file name)")
    parser.add_argument("--format", "-f", dest="format",
                        help="output file format (default pdf)")
    parser.add_argument("--width", "-x", dest="width", type=int,
                        help="output file width in inches (default 20)")
    parser.add_argument("--height", "-y", dest="height", type=int,
                        help="output file height in inches (default 15)")
    parser.add_argument("files", nargs="+",
                        help="vdsm log files to process")
    parser.set_defaults(name=None, format="pdf", width=20, height=15)
    return parser.parse_args(args)


Log = namedtuple("Log", "thread,loglevel,timestamp,module,lineno,logger,text")


class Stats(object):
    def __init__(self):
        self.repostats = defaultdict(DomainStats)
        self.lvm_commands = defaultdict(CommandStats)


class DomainStats(object):
    def __init__(self):
        self.timestamp = []
        self.lastcheck = []
        self.delay = []


class CommandStats(object):
    def __init__(self):
        self.timestamp = []
        self.runtime = []
        self.running = False


def parse(files):
    """
    Parse patterns from vdsm log and return Stats object.
    """
    patterns = [
        # Match repoStats response log:
        # jsonrpc.Executor/5::INFO::2016-02-17
        # 19:26:33,837::logUtils::51::dispatcher::(wrapper) Run and protect:
        # repoStats, Return response: ...
        (add_repostats, "Run and protect: repoStats, Return response:",
            "repostats"),

        # Match LVM commands begin or end logs.
        #
        # Begin:
        # Thread-61::DEBUG::2016-02-17
        # 19:26:33,854::lvm::286::Storage.Misc.excCmd::(cmd) /usr/bin/taskset
        # --cpu-list 0-7 /usr/bin/sudo -n /usr/sbin/lvm vgck ...
        #
        # End:
        # Thread-61::DEBUG::2016-02-17
        # 19:26:37,933::lvm::286::Storage.Misc.excCmd::(cmd) SUCCESS: ...
        (add_command, "::Storage.Misc.excCmd::(cmd)", "lvm_commands"),
    ]

    stats = Stats()

    for line in fileinput.input(files):
        for func, pattern, name in patterns:
            if pattern in line:
                log = parse_log(line)
                substats = getattr(stats, name)
                func(substats, log)

    return stats


def add_repostats(repostats, log):
    """
    Add repostats samples from repoStats response line
    """
    start = log.text.find("{")
    response = eval(log.text[start:])
    for uuid, info in response.items():
        ds = repostats[uuid]
        ds.timestamp.append(log.timestamp)
        ds.lastcheck.append(float(info["lastCheck"]))
        ds.delay.append(float(info["delay"]))


def add_command(commands, log):
    """
    Add commands start and stop events from execCmd calls
    """
    cs = commands[log.thread]
    if " SUCCESS:" in log.text or " ERROR:" in log.text:
        if not cs.running:
            return
        cs.running = False
        timedelta = log.timestamp - cs.timestamp[-1]
        cs.timestamp.append(log.timestamp)
        cs.runtime.append(timedelta.total_seconds())
        # Add zero in the same timestamp, to get nicer triangles in the plots.
        cs.timestamp.append(log.timestamp)
        cs.runtime.append(0)
    else:
        cs.running = True
        cs.timestamp.append(log.timestamp)
        cs.runtime.append(0)


def parse_log(line):
    # MainThread::DEBUG::2016-02-17
    # 19:26:03,875::sp::398::Storage.StoragePool::(cleanupMasterMount) ...
    fields = line.split("::", 7)
    timestamp = fields[2]
    timestamp = timestamp.replace(",", ".")
    fields[2] = pandas.Timestamp(timestamp)
    return Log(*fields)


def dataframe(stats, key):
    """
    Create pandas.DataFrame with one column per domain for given key.
    """
    dfs = []
    for uuid, ds in stats.iteritems():
        df = pandas.DataFrame(getattr(ds, key), index=ds.timestamp,
                              columns=[uuid])
        dfs.append(df)
    combined = pandas.concat(dfs, axis=1)
    return combined


def plot(stats, filename, size):
    pyplot.figure(figsize=size, dpi=300)

    pyplot.subplot(311)
    pyplot.title("lastCheck")
    pyplot.ylabel("lastCheck (seconds)")
    pyplot.xlabel("time")
    pyplot.grid(True)

    lastcheck = dataframe(stats.repostats, "lastcheck")
    pyplot.plot(lastcheck.index, lastcheck)

    pyplot.axhline(y=30, color="gray", linewidth="2")

    # Show values up to 330 seconds. Bigger values will cause a host to become
    # non-operational.
    pyplot.axis([lastcheck.index[0], lastcheck.index[-1], 0, 330])

    pyplot.subplot(312)
    pyplot.title("read delay")
    pyplot.ylabel("delay (seconds)")
    pyplot.xlabel("time")
    pyplot.grid(True)

    delay = dataframe(stats.repostats, "delay")
    pyplot.plot(delay.index, delay)

    pyplot.axhline(y=5, color="gray", linewidth="2")

    # Show values up to 10 seconds. Values bigger then 5 seconds will show a
    # warning in engine log.
    pyplot.axis([lastcheck.index[0], lastcheck.index[-1], 0, 10])

    pyplot.subplot(313)
    pyplot.title("LVM commands")
    pyplot.ylabel("runtime (seconds)")
    pyplot.xlabel("time")
    pyplot.xlim(lastcheck.index[0], lastcheck.index[-1])
    pyplot.grid(True)

    for thread, cs in stats.lvm_commands.iteritems():
        pyplot.plot(cs.timestamp, cs.runtime)

    pyplot.savefig(filename, bbox_inches="tight")


if __name__ == "__main__":
    main(sys.argv[1:])
