import os
import sys
import subprocess
from nose.plugins.skip import SkipTest

from testrunner import VdsmTestCase as TestCaseBase

EXT_ECHO = "/bin/echo"

if __name__ != "__main__":
    # This will not be available when we use this module as a subprocess
    from vdsm.betterPopen import BetterPopen


class TestBetterPopen(TestCaseBase):
    def testEcho(self):
        data = "Hello"
        p = BetterPopen([EXT_ECHO, "-n", data])
        p.wait()
        self.assertTrue(p.returncode == 0,
                "Process failed: %s" % os.strerror(p.returncode))
        self.assertEquals(p.stdout.read(), data)

    def testCat(self):
        path = "/etc/passwd"
        p = BetterPopen(["cat", path])
        p.wait()
        self.assertTrue(p.returncode == 0,
                "Process failed: %s" % os.strerror(p.returncode))
        with open(path, "r") as f:
            self.assertEquals(p.stdout.read(), f.read())

    def _subTest(self, name, params, *args, **kwargs):
        p = BetterPopen(["python", __file__, name] + params,
                *args, **kwargs)
        p.wait()
        self.assertTrue(p.returncode == 0,
                "Process failed: %s" % os.strerror(p.returncode))
        self.assertEquals(p.stdout.read().strip(), "True")

    def testCloseFDs(self):
        fds = os.pipe()
        try:
            self._subTest("fds", [str(fds[1])], close_fds=True)
        finally:
            os.close(fds[0])
            os.close(fds[1])

    def testNoCloseFds(self):
        fds = os.pipe()
        try:
            self._subTest("nofds", [str(fds[1])], close_fds=False)
        finally:
            os.close(fds[0])
            os.close(fds[1])

    def testEnv(self):
        env = os.environ.copy()
        env["TEST"] = "True"
        self._subTest("env", [], env=env)

    def testCwd(self):
        cwd = "/proc"
        p = BetterPopen(["python", "-c", "import os; print os.getcwd()"],
                cwd=cwd)
        p.wait()
        self.assertTrue(p.returncode == 0,
                "Process failed: %s" % os.strerror(p.returncode))
        self.assertEquals(p.stdout.read().strip(), cwd)

    def testRunNonExecutable(self):
        self.assertRaises(OSError, BetterPopen, ["/tmp"])

    def testBadCwd(self):
        self.assertRaises(OSError, BetterPopen, ["echo", "hello"],
        cwd="/~~~~~dasdas~~~~")

    def testUnicodeArg(self):
        data = u'hello'
        cmd = [EXT_ECHO, "-n", data]

        p = BetterPopen(cmd)
        p.wait()
        p2 = subprocess.Popen(cmd, stdin=subprocess.PIPE,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p2.wait()
        self.assertEquals(p.stdout.read(), p2.stdout.read())

    def testNonASCIIUnicodeArg(self):
        data = u'\u05e9\u05dc\u05d5\u05dd'
        # If the default encoding is not utf-8 the test *should* fail as non
        # ascii conversion shouldn't work
        if sys.getfilesystemencoding() != "UTF-8":
            raise SkipTest("The default encoding isn't unicode")

        cmd = [EXT_ECHO, "-n", data]

        p = BetterPopen(cmd)
        p.wait()
        p2 = subprocess.Popen(cmd, stdin=subprocess.PIPE,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p2.wait()
        self.assertEquals(p.stdout.read(), p2.stdout.read())


if __name__ == "__main__":
    cmd = sys.argv[1]
    if cmd == "fds":
        try:
            os.close(int(sys.argv[2]))
            print "False"
        except:
            print "True"

    elif cmd == "nofds":
        try:
            os.close(int(sys.argv[2]))
            print "True"
        except:
            print "False"

    elif cmd == "env":
        try:
            print os.environ.get("TEST", "False")
        except:
            print "False"
