#!/usr/bin/env python
#
# Copyright 2016 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Refer to the README and COPYING files for full details of the license
#
"""
Usage: schema-converter json_schema_path yaml_schema_path

Converts json schema into yaml schema.

json_schema_path - path where json schema is located

yaml_schema_path - path where yaml schema is written
"""
import sys
from collections import OrderedDict

import yaml

from api import json_schema
from api import vdsmapi

versions = {
    '4.10.0': '3.1',
    '4.10.1': '3.1',
    '4.10.3': '3.2',
    '4.11.0': '3.2',
    '4.11.1': '3.2',
    '4.12.0': '3.2',
    '4.13.0': '3.3',
    '4.14.0': '3.4',
    '4.14.1': '3.4',
    '4.15.0': '3.4',
    '4.16.0': '3.5',
    '4.16.7': '3.5',
    '4.16.8': '3.5',
    '4.16.13': '3.5',
    '4.17': '3.6',
    '4.17.0': '3.6',
    '4.17.14': '3.6',
    '4.17.17': '3.6',
    '4.17.5': '3.6',
    '4.18.0': '4.0',
    '4.18': '4.0'
}


primitive_types = ['boolean',
                   'dict',
                   'float',
                   'int',
                   'string',
                   'uint']


def name_filter(name):
    if name.startswith('*'):
        name = name[1:]
    return name


def check_str(name):
    if name == 'str':
        name = 'string'
    return name


def check_bool(name):
    if name == 'bool':
        name = 'boolean'
    return name


def check_type(name):
    is_list = False
    if isinstance(name, list):
        name = name[0]
        is_list = True
    if name.startswith('[') and name.endswith(']'):
        name = name[1:-1]
        is_list = True

    name = check_str(check_bool(name))
    if is_list:
        name = [name]
    return name


def check_optional(desc):
    return desc.startswith('#optional')


def convert_commands(symbol):
    commands = {}
    for class_name in symbol.keys():
        verbs = symbol.get(class_name)
        for verb in verbs.values():
            command = {'description': verb.get('desc')}

            version = verb.get('since')
            if version is not None:
                command['added'] = versions.get(version)

            data = verb.get('data')
            if data is not None:
                params = []
                data_info = verb.get('info_data')
                for name in data.keys():
                    param = {'name': name_filter(name)}

                    param['type'] = check_type(data.get(name))

                    desc = data_info.get(name_filter(name))
                    if check_optional(desc):
                        param['defaultvalue'] = 'needs updating'
                        desc = desc[10:]
                    param['description'] = desc.strip()

                    params.append(param)
                command['params'] = params

            ret_typ = verb.get('returns')
            if ret_typ is not None:
                ret = {
                    'description': verb.get('info_return').strip(),
                    'type': check_type(verb.get('returns'))
                }
                command['return'] = ret
            commands[verb.get('name')] = command
    return commands


def convert_aliases(symbol):
    aliases = {}
    for content in symbol.values():
        alias = {'name': content.get('name'),
                 'type': 'alias',
                 'sourcetype': content.get('data'),
                 'description': content.get('desc'),
                 'added': versions.get(content.get('since'))}
        aliases[content.get('name')] = alias
    return aliases


def convert_maps(symbol):
    maps = {}
    for content in symbol.values():
        map = {'name': content.get('name'),
               'description': content.get('desc'),
               'key-type': check_type(content.get('key')),
               'value-type': check_type(content.get('value')),
               'type': 'map',
               'added': versions.get(content.get('since'))}
        maps[content.get('name')] = map
    return maps


def convert_unions(symbol):
    unions = {}
    for content in symbol.values():
        if 'union' not in content.keys():
            continue
        union = {'name': content.get('name'),
                 'description': content.get('desc'),
                 'added': versions.get(content.get('since')),
                 'type': 'union'}
        values = content.get('union')
        union['values'] = ['boolean' if value == 'bool' else
                           value for value in values]
        data = content.get('data')
        if data is not None and len(data.keys()) > 0:
            params = []
            info_data = content.get('info_data')
            for name in data.keys():
                desc = info_data.get(name)
                params.append({'name': name,
                               'description': desc,
                               'type': check_type(data.get(name))})
            union['properties'] = params
        unions[content.get('name')] = union

    return unions


def convert_enums(symbol):
    enums = {}
    for content in symbol.values():
        enum = {'name': content.get('name'),
                'description': content.get('desc'),
                'type': 'enum',
                'added': versions.get(content.get('since')),
                'values': content.get('info_data')}
        enums[content.get('name')] = enum
    return enums


def convert_types(symbol):
    types = {}
    for content in symbol.values():
        if content.get('union') is not None:
            continue

        type = {'name': content.get('name'),
                'type': 'object',
                'description': content.get('desc'),
                'added': versions.get(content.get('since'))}

        info_data = content.get('info_data')
        params = []
        for name in info_data.keys():
            param = {'name': name}

            desc = info_data.get(name)
            if check_optional(desc):
                desc = desc[10:]
                param['defaultvalue'] = 'needs updating'

            param['description'] = desc

            data = content.get('data', content)
            value = data.get(name)
            if value is None:
                value = data.get('*' + name)
            param['type'] = check_type(value)
            params.append(param)
        type['properties'] = params

        types[content.get('name')] = type
    return types


def update_type(map, all, key):
    is_list = False
    key_type = map.get(key)

    if isinstance(key_type, list):
        key_type = key_type[0]
        is_list = True

    if key_type not in primitive_types:
        value = all.get(key_type)
        if is_list:
            map[key] = [value]
        else:
            map[key] = value


def create_references_for_maps(maps, all):
    for map in maps.values():
        update_type(map, all, 'key-type')
        update_type(map, all, 'value-type')


def create_references_for_types(types, all):
    for type in types.values():
        if 'properties' in type:
            for param in type.get('properties'):
                update_type(param, all, 'type')


def create_references_for_unions(unions, all):
    for union in unions.values():
        values = []
        for value in union.get('values'):
            if value in primitive_types:
                values.append(value)
            else:
                values.append(all.get(value))
        union['values'] = values
        if 'params' in union.keys():
            for param in union.get('params'):
                update_type(param, all, 'type')


def create_references_for_commands(commands, all):
    for command in commands.values():
        if 'return' in command.keys():
            ret = command.get('return')
            update_type(ret, all, 'type')
        if 'params' in command.keys():
            for param in command.get('params'):
                update_type(param, all, 'type')


class Anchor(yaml.Dumper):
    """
    Anchor is created whenever there is first occurrence
    of an object and all the other references are aliases.
    """

    def generate_anchor(self, node):
        """
        We need to customize anchor and alias naming to use
        type name instead of 'id%03d' id
        """
        for key_node, value_node in node.value:
            if key_node.value == 'name':
                return value_node.value
        return super(Anchor, self).generate_anchor(node)


def write_schema(f, symbols):
    # self containing types
    all_types = convert_aliases(symbols.get('aliases'))
    all_types.update(convert_enums(symbols.get('enums')))

    # types which require reference updates
    maps = convert_maps(symbols.get('maps'))
    all_types.update(maps)
    types = convert_types(symbols.get('types'))
    all_types.update(types)
    # unions are wrongly parsed in the old code so we use types
    unions = convert_unions(symbols.get('types'))
    all_types.update(unions)

    # commands require reference updates
    commands = convert_commands(symbols.get('commands'))

    create_references_for_maps(maps, all_types)
    create_references_for_types(types, all_types)
    create_references_for_unions(unions, all_types)
    create_references_for_commands(commands, all_types)

    # make sure that types are first
    data = commands
    data['types'] = all_types

    yaml.add_representer(OrderedDict,
                         yaml.representer.SafeRepresenter.represent_dict)

    f.write(yaml.dump(data, indent=4, width=80,
                      default_flow_style=False, Dumper=Anchor))


def main(args):
    if len(args) < 2:
        print(__doc__)
        sys.exit(2)

    json_path = args[0]
    yaml_path = args[1]

    api = vdsmapi.get_api(json_path)

    with open(json_path) as f:
        symbols = json_schema.read_schema_doc(f, api)

    with open(yaml_path, 'w') as f:
        write_schema(f, symbols)


if __name__ == "__main__":
    main(sys.argv[1:])
